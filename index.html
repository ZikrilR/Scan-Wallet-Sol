<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>NEO//SOL — Wallet Scanner</title>

  <!-- Futuristic font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg0:#04040a; --bg1:#0a0712;
      --glass:rgba(12,10,18,.54);
      --glass2:rgba(255,255,255,.06);
      --border:rgba(255,70,120,.24);
      --border2:rgba(0,229,255,.18);
      --red:#ff2d55; --vio:#8b5cff; --cyan:#00e5ff;
      --text:#f3f4ff; --muted:#a6a8c2; --ok:#32ff9a; --err:#ff3b30;
      --shadow:0 18px 80px rgba(0,0,0,.64);
      --glow:0 0 0 1px rgba(255,45,85,.22), 0 0 44px rgba(255,45,85,.12);
      --glowC:0 0 0 1px rgba(0,229,255,.20), 0 0 44px rgba(0,229,255,.10);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, monospace;
      --neo: "Orbitron", ui-sans-serif, system-ui;
      --ui: "Inter", ui-sans-serif, system-ui;
    }

    *{ box-sizing:border-box; }
    html, body { height:100%; }

    body{
      margin:0;
      padding:18px;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      font-family:var(--ui);
      color:var(--text);
      background:
        radial-gradient(900px 520px at 15% 5%, rgba(255,45,85,.22), transparent 60%),
        radial-gradient(820px 520px at 80% 20%, rgba(139,92,255,.16), transparent 55%),
        radial-gradient(900px 700px at 40% 120%, rgba(0,229,255,.10), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }

    /* Sol coin watermark */
    body::before{
      content:"";
      position:fixed;
      inset:0;
      z-index:-1;
      pointer-events:none;

      background-image:url("https://static.vecteezy.com/system/resources/previews/024/093/328/original/solana-sol-glass-crypto-coin-3d-illustration-free-png.png");
      background-repeat:no-repeat;
      background-position: 86% 38%;
      background-size: min(560px, 78vw);
      opacity:.14;

      filter: drop-shadow(0 0 28px rgba(255,45,85,.26))
              drop-shadow(0 0 22px rgba(0,229,255,.18));
      animation: floatCoin 9s ease-in-out infinite;
    }

    @keyframes floatCoin{
      0%,100%{ transform: translate3d(0,0,0) rotate(-2deg); }
      50%{ transform: translate3d(-12px, 14px, 0) rotate(2deg); }
    }

    /* Animated grid */
    .gridBg{
      position:fixed;
      inset:-22%;
      background:
        linear-gradient(rgba(255,255,255,.06) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,.06) 1px, transparent 1px);
      background-size: 48px 48px;
      transform: perspective(900px) rotateX(64deg) translateY(-120px);
      opacity:.16;
      filter: blur(.2px);
      animation: drift 14s linear infinite;
      pointer-events:none;
      z-index:-2;
    }

    @keyframes drift{
      from{ background-position:0 0, 0 0; }
      to{ background-position:0 480px, 480px 0; }
    }

    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce){
      .gridBg{ animation:none; }
      body::before{ animation:none; }
      .scanline{ animation:none; }
      .pulseDot{ animation:none; }
    }

    .wrap{ max-width:1240px; margin:0 auto; width:100%; }
    main{ width:100%; flex: 1 0 auto; }

    /* Header */
    .top{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:14px;
      flex-wrap:wrap;
      margin-bottom:14px;
    }

    .brand{
      display:flex;
      flex-direction:column;
      gap:6px;
    }

    .title{
      margin:0;
      font-family:var(--neo);
      font-size:18px;
      letter-spacing:.22em;
      text-transform:uppercase;
      text-shadow: 0 0 18px rgba(0,229,255,.12), 0 0 24px rgba(255,45,85,.12); /* text-shadow [web:528] */
    }

    .subtitle{
      margin:0;
      color:rgba(255,255,255,.74);
      font-size:12px;
      letter-spacing:.08em;
    }

    .badge{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-radius:999px;
      background: linear-gradient(180deg, rgba(255,45,85,.12), rgba(0,229,255,.06));
      border:1px solid rgba(255,255,255,.10);
      box-shadow: var(--glowC);
      font-size:12px;
      white-space:nowrap;
    }

    .pulseDot{
      width:10px; height:10px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #fff, var(--cyan));
      box-shadow: 0 0 18px rgba(0,229,255,.55);
      animation: pulse 1.6s infinite ease-in-out;
    }
    @keyframes pulse{
      0%,100%{ transform:scale(1); opacity:.95 }
      50%{ transform:scale(.72); opacity:.6 }
    }

    /* Glass card */
    .glass{
      background: var(--glass);
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow), var(--glow);
      backdrop-filter: blur(14px); /* backdrop-filter [web:535] */
      -webkit-backdrop-filter: blur(14px);
      overflow:hidden;
      position:relative;
    }

    .glass::after{
      content:"";
      position:absolute;
      inset:-2px;
      background:
        radial-gradient(800px 200px at 20% 0%, rgba(0,229,255,.10), transparent 55%),
        radial-gradient(700px 220px at 80% 10%, rgba(255,45,85,.12), transparent 60%);
      pointer-events:none;
      opacity:.8;
      mix-blend-mode: screen;
    }

    .scanline{
      position:absolute;
      inset:0;
      background: linear-gradient(transparent, rgba(0,229,255,.07), transparent);
      transform: translateY(-120%);
      animation: scan 5.4s ease-in-out infinite;
      pointer-events:none;
      opacity:.9;
    }
    @keyframes scan{
      0%{ transform: translateY(-120%); opacity:0; }
      15%{ opacity:.6; }
      55%{ opacity:.35; }
      100%{ transform: translateY(120%); opacity:0; }
    }

    .panel{ padding:16px; }

    .grid{
      display:grid;
      grid-template-columns:repeat(12, 1fr);
      gap:12px;
      align-items:end;
      position:relative;
      z-index:1; /* above glass ::after */
    }

    .field{ grid-column:span 3; min-width:0; }
    .field.wide{ grid-column:span 6; }
    .field.small{ grid-column:span 2; }

    label{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-size:11px;
      color:rgba(255,255,255,.70);
      margin:0 0 7px;
      letter-spacing:.06em;
      text-transform:uppercase;
    }

    .kpi{
      font-family:var(--mono);
      font-size:11px;
      color:rgba(255,255,255,.55);
    }

    input, button{
      width:100%;
      padding:10px 12px;
      font-size:14px;
      border-radius:14px;
      outline:none;
    }

    input{
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      color:var(--text);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.20);
    }

    input::placeholder{ color: rgba(255,255,255,.40); }

    .btnRow{
      display:flex;
      gap:10px;
    }

    button{
      cursor:pointer;
      border:1px solid rgba(255,45,85,.36);
      background: linear-gradient(135deg, rgba(255,45,85,.95), rgba(139,92,255,.74));
      color:#070611;
      font-weight:900;
      letter-spacing:.06em;
      text-transform:uppercase;
      box-shadow:0 16px 40px rgba(255,45,85,.18);
      transition: transform .12s ease, filter .12s ease;
      font-family:var(--neo);
      font-size:12px;
    }
    button:hover{ transform: translateY(-1px); filter: brightness(1.03); }
    button:disabled{ opacity:.58; cursor:not-allowed; transform:none; }

    .ghostBtn{
      border:1px solid rgba(0,229,255,.30);
      background: linear-gradient(180deg, rgba(0,229,255,.14), rgba(255,255,255,.04));
      color:rgba(255,255,255,.88);
      box-shadow: var(--glowC);
    }

    .status{
      margin-top:12px;
      font-size:13px;
      color:rgba(255,255,255,.72);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      position:relative;
      z-index:1;
    }
    .status .ok{ color:var(--ok); font-weight:900; }
    .status .err{ color:var(--err); font-weight:900; }

    .bar{
      flex:1 1 340px;
      height:10px;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .bar > div{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(0,229,255,.85), rgba(255,45,85,.88));
      box-shadow: 0 0 22px rgba(0,229,255,.25);
      transition: width .18s ease;
    }

    .tableWrap{
      margin-top:14px;
      overflow:auto;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      box-shadow: 0 20px 80px rgba(0,0,0,.35);
    }
    table{
      width:100%;
      border-collapse:collapse;
      min-width:1120px;
    }
    thead th{
      position:sticky;
      top:0;
      background: rgba(0,229,255,.06);
      border-bottom: 1px solid rgba(0,229,255,.16);
      color:rgba(255,255,255,.88);
      text-align:left;
      padding:11px 10px;
      font-size:11px;
      letter-spacing:.18em;
      text-transform:uppercase;
      white-space:nowrap;
      font-family:var(--neo);
    }
    tbody td{
      padding:10px;
      border-bottom:1px solid rgba(255,255,255,.06);
      vertical-align:top;
      font-size:13px;
      color:rgba(255,255,255,.92);
      white-space:nowrap;
    }
    tbody tr:hover{ background: rgba(255,45,85,.06); }
    .mono{ font-family:var(--mono); }
    .num{ font-variant-numeric: tabular-nums; }
    .pos{ color:var(--ok); font-weight:900; }
    .neg{ color:var(--err); font-weight:900; }

    details{ margin-top:12px; }
    summary{ cursor:pointer; color:rgba(255,255,255,.62); font-family:var(--neo); letter-spacing:.12em; font-size:11px; text-transform:uppercase; }
    pre{
      margin-top:10px;
      padding:12px;
      background: rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      color: rgba(255,255,255,.84);
      overflow:auto;
      max-height:360px;
      white-space:pre-wrap;
      word-break:break-word;
      font-family:var(--mono);
      font-size:12px;
    }

    footer{
      margin-top:auto;
      margin-bottom:10px;
      padding:12px 12px;
      border-radius:16px;
      font-family:var(--neo);
      letter-spacing:.14em;
      text-transform:uppercase;
      font-size:11px;
      color:rgba(255,255,255,.78);
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
    }
    footer .sep{ color: rgba(255,255,255,.35); }

    @media (max-width: 980px){
      .field{ grid-column:span 6; }
      .field.small{ grid-column:span 3; }
      .field.wide{ grid-column:span 12; }
      table{ min-width: 1020px; }
    }
    @media (max-width: 560px){
      body{ padding:12px; }
      .field{ grid-column:span 12; }
      .field.small{ grid-column:span 6; }
      table{ min-width: 920px; }
    }
  </style>
</head>

<body>
  <div class="gridBg"></div>

  <main class="wrap">
    <div class="top">
      <div class="brand">
        <h1 class="title">NEO//SOL — Wallet Scanner</h1>
        <p class="subtitle">DAS holdings + RPC proxy + USDC-only PnL • “future-grade” portfolio probe</p>
      </div>
      <div class="badge">
        <span class="pulseDot"></span>
        <span id="netBadge">LINK: VERCEL / RPC PROXY</span>
      </div>
    </div>

    <section class="glass panel">
      <div class="scanline"></div>

      <div class="grid">
        <div class="field wide">
          <label>Helius API Key <span class="kpi mono" id="kApi">—</span></label>
          <input id="apiKey" type="password" autocomplete="off" placeholder="Helius API key"/>
        </div>

        <div class="field wide">
          <label>Wallet Address <span class="kpi mono" id="kWallet">—</span></label>
          <input id="owner" placeholder="Masukkan wallet address (base58)"/>
        </div>

        <div class="field small">
          <label>Holdings <span class="kpi mono">DAS</span></label>
          <input id="limitAssets" type="number" min="1" max="1000" value="200"/>
        </div>

        <div class="field small">
          <label>Signatures <span class="kpi mono">RPC</span></label>
          <input id="limitTx" type="number" min="10" max="200" value="80"/>
        </div>

        <div class="field small">
          <label>Tx details <span class="kpi mono">RPC</span></label>
          <input id="maxDetails" type="number" min="5" max="80" value="25"/>
        </div>

        <div class="field small">
          <label>Min USD <span class="kpi mono">Filter</span></label>
          <input id="minUsd" type="number" value="1"/>
        </div>

        <div class="field small">
          <label>Auto refresh <span class="kpi mono">sec</span></label>
          <input id="refreshSec" type="number" min="0" max="300" value="15"/>
        </div>

        <div class="field small">
          <label>&nbsp;</label>
          <div class="btnRow">
            <button id="btnAnalyze">Analyze</button>
            <button id="btnAuto" class="ghostBtn" title="Toggle auto refresh">Auto: OFF</button>
          </div>
        </div>
      </div>

      <div class="status">
        <div id="statusText">Ready.</div>
        <div class="bar" aria-label="progress"><div id="barFill"></div></div>
      </div>
    </section>

    <div class="tableWrap" id="tableWrap" style="display:none;">
      <table>
        <thead>
          <tr>
            <th>#</th>
            <th>Token</th>
            <th>Mint</th>
            <th class="num">Amount</th>
            <th class="num">Entry</th>
            <th class="num">Current</th>
            <th class="num">Holdings USD</th>
            <th class="num">Sold USD</th>
            <th class="num">PnL USD</th>
            <th class="num">PnL %</th>
            <th>Notes</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>

    <details>
      <summary>Raw telemetry (debug)</summary>
      <pre id="raw">{}</pre>
    </details>
  </main>

  <footer class="glass">
    <span class="mono">© <span id="yy"></span></span>
    <span class="sep">•</span>
    <span>ZeecDev Research Console</span>
  </footer>

<script>
  document.getElementById("yy").textContent = new Date().getFullYear();

  // ============ CONFIG ============
  const RPC_PROXY = "/api/rpc";
  const HELIUS_API_KEY_DEFAULT = "98e4a328-4c19-4799-8d81-de84e2c55f9d";
  const USDC_MINT = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";

  // ============ UTIL ============
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));
  const el = (id) => document.getElementById(id);

  function setProgress(pct){ el("barFill").style.width = `${Math.max(0, Math.min(100, pct))}%`; }
  function setStatus(msg, kind="muted"){
    const cls = kind==="err" ? "err" : (kind==="ok" ? "ok" : "");
    el("statusText").innerHTML = cls ? `<span class="${cls}">${msg}</span>` : msg;
  }

  function shortAddr(a){
    if (!a) return "—";
    return a.slice(0, 4) + "…" + a.slice(-4);
  }

  function fmtUsd(x){
    if (!Number.isFinite(x)) return "—";
    return "$" + x.toLocaleString("en-US", { maximumFractionDigits:2 });
  }
  function fmtPrice(x){
    if (!Number.isFinite(x) || x === 0) return "—";
    return "$" + x.toFixed(10);
  }
  function fmtMint(m){
    if (!m) return "";
    return m.slice(0, 4) + "…" + m.slice(-4);
  }

  // ============ STATE (auto refresh incremental) ============
  let AUTO_TIMER = null;
  let AUTO_ON = false;

  let PROCESSED_SIGS = new Set();
  let LAST_WALLET = "";
  let LAST_TOKENS = null;
  let LAST_LEDGER = new Map();

  function stopAuto(){
    if (AUTO_TIMER){
      clearInterval(AUTO_TIMER); // clearInterval stops a timer created by setInterval [web:479]
      AUTO_TIMER = null;
    }
  }

  function setAutoUi(on){
    AUTO_ON = !!on;
    el("btnAuto").textContent = `Auto: ${AUTO_ON ? "ON" : "OFF"}`;
  }

  function startAuto(wallet, refreshSec, maxDetails){
  stopAuto();
  if (!AUTO_ON) return;
  if (!refreshSec || refreshSec <= 0) return;

  AUTO_TIMER = setInterval(async () => {
    try{
      const apiKey = el("apiKey").value.trim();
      const limitAssets = Number(el("limitAssets").value || 200);
      const minUsd = Number(el("minUsd").value || 0);

      // 1) refresh price/holdings (biar PnL USD ikut bergerak)
      await refreshHoldingsOnly(apiKey, wallet, limitAssets);

      // 2) refresh ledger tx baru (batasi kecil biar gak 429)
      const r = await updatePnlOnly(wallet, Math.min(3, maxDetails));

      // 3) render ulang WALAU newTx = 0 (price bisa berubah)
      if (LAST_TOKENS){
        setStatus(`AUTO SYNC: price refreshed • +${r.newTx} tx`, r.newTx > 0 ? "ok" : "muted");
        render(LAST_TOKENS, LAST_LEDGER, minUsd);
      }
    }catch(e){
      setStatus(`AUTO SYNC error: ${e.message}`, "err");
    }
  }, refreshSec * 1000);
}


  // ============ Helius DAS ============
  function heliusRpcUrl(apiKey){
    return `https://mainnet.helius-rpc.com/?api-key=${apiKey}`;
  }

  async function heliusRpcCall(apiKey, method, params){
    const res = await fetch(heliusRpcUrl(apiKey), {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ jsonrpc:"2.0", id:"helius", method, params })
    });
    const json = await res.json();
    if (json.error) throw new Error(json.error.message || JSON.stringify(json.error));
    return json.result;
  }

  async function fetchFungibleHoldings(apiKey, ownerAddress, limit){
    return await heliusRpcCall(apiKey, "searchAssets", {
      ownerAddress,
      tokenType:"fungible",
      page:1,
      limit,
      displayOptions:{ showNativeBalance:true }
    });
  }

  function pickItems(result){
    if (result && Array.isArray(result.items)) return result.items;
    if (result && result.assets && Array.isArray(result.assets.items)) return result.assets.items;
    return [];
  }

  function normalizeFungiblesFromDas(result){
    const items = pickItems(result);
    return items.map(it => {
      const info = it.token_info || {};
      const mint = it.id || info.mint || info.address || "";
      const raw = Number(info.balance ?? info.amount ?? 0);
      const decimals = Number(info.decimals ?? 0);
      const dasPrice = Number(info.price_info?.price_per_token ?? 0);
      return {
        mint,
        symbol: info.symbol || it.content?.metadata?.symbol || "UNKNOWN",
        name: info.name || it.content?.metadata?.name || "Unknown",
        decimals,
        rawAmount: raw,
        dasPrice
      };
    }).filter(t => t.mint && Number.isFinite(t.rawAmount) && t.rawAmount > 0);
  }

  // ============ Solana RPC via Vercel proxy ============
  async function rpcRaw(method, params){
    const res = await fetch(RPC_PROXY, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ jsonrpc:"2.0", id:method, method, params })
    });
    const json = await res.json();
    if (json.error) throw new Error(json.error.message || JSON.stringify(json.error));
    return json.result;
  }

  async function getSignaturesForAddress(wallet, limit=80){
    const cfg = { limit: Math.max(1, Math.min(1000, Number(limit) || 80)), commitment:"confirmed" };
    return await rpcRaw("getSignaturesForAddress", [wallet, cfg]);
  }

  async function getTransaction(signature){
    return await rpcRaw("getTransaction", [
      signature,
      { encoding:"jsonParsed", commitment:"confirmed", maxSupportedTransactionVersion:0 }
    ]);
  }

  // ============ PnL (USDC-only) ============
  function uiAmountFromTokenBalance(tb){
    const ui = tb?.uiTokenAmount;
    if (!ui) return 0;

    const s = ui.uiAmountString ?? null;
    if (s !== null && s !== undefined){
      const v = Number(s);
      return Number.isFinite(v) ? v : 0;
    }

    const raw = Number(ui.amount ?? 0);
    const dec = Number(ui.decimals ?? 0);
    if (!Number.isFinite(raw)) return 0;
    return dec ? raw / Math.pow(10, dec) : raw;
  }

  function computeWalletTokenDeltas(tx, wallet){
    const pre = Array.isArray(tx?.meta?.preTokenBalances) ? tx.meta.preTokenBalances : [];
    const post = Array.isArray(tx?.meta?.postTokenBalances) ? tx.meta.postTokenBalances : [];
    const key = (b) => `${b.accountIndex}|${b.mint}|${b.owner || ""}`;

    const preMap = new Map();
    for (const b of pre) preMap.set(key(b), b);

    const postMap = new Map();
    for (const b of post) postMap.set(key(b), b);

    const keys = new Set([...preMap.keys(), ...postMap.keys()]);
    const out = new Map();

    for (const k of keys){
      const a = preMap.get(k);
      const b = postMap.get(k);
      const owner = (b?.owner || a?.owner || "");
      if (owner !== wallet) continue;

      const mint = b?.mint || a?.mint;
      if (!mint) continue;

      const preUi = a ? uiAmountFromTokenBalance(a) : 0;
      const postUi = b ? uiAmountFromTokenBalance(b) : 0;
      const d = postUi - preUi;
      if (!Number.isFinite(d) || d === 0) continue;

      out.set(mint, (out.get(mint) || 0) + d);
    }
    return out;
  }

  function ensureLedger(map, mint){
    if (!map.has(mint)) map.set(mint, { buyUsd:0, buyQty:0, sellUsd:0, notes:new Set() });
    return map.get(mint);
  }

  function buildLedgerFromTxs(txs, wallet){
    const ledger = new Map();

    for (const tx of txs){
      if (!tx?.meta || tx?.meta?.err) continue;

      const d = computeWalletTokenDeltas(tx, wallet);
      const dUsdc = d.get(USDC_MINT) || 0;
      d.delete(USDC_MINT);

      const entries = [...d.entries()];
      if (entries.length !== 1) continue;

      const [mint, dTok] = entries[0];
      if (!mint || !Number.isFinite(dTok) || dTok === 0) continue;
      if (!Number.isFinite(dUsdc) || dUsdc === 0) continue;

      if (dTok > 0 && dUsdc < 0){
        const e = ensureLedger(ledger, mint);
        e.buyUsd += (-dUsdc);
        e.buyQty += dTok;
        e.notes.add("USDC-buy");
        continue;
      }
      if (dTok < 0 && dUsdc > 0){
        const e = ensureLedger(ledger, mint);
        e.sellUsd += dUsdc;
        e.notes.add("USDC-sell");
        continue;
      }
    }

    for (const [mint, v] of ledger.entries()){
      v.notes = [...v.notes].join(",");
      ledger.set(mint, v);
    }
    return ledger;
  }

  // Incremental update: only process unseen signatures
  async function updatePnlOnly(wallet, maxDetails){
    const sigs = await getSignaturesForAddress(wallet, 50);
    const newest = sigs.map(s => s.signature).filter(Boolean);

    const todo = [];
    for (const s of newest){
      if (!PROCESSED_SIGS.has(s)) todo.push(s);
      if (todo.length >= maxDetails) break;
    }
    if (!todo.length) return { newTx: 0 };

    const txs = [];
    for (let i = 0; i < todo.length; i++){
      try{
        const tx = await getTransaction(todo[i]);
        if (tx) txs.push(tx);
        PROCESSED_SIGS.add(todo[i]);
      }catch(e){}
      await sleep(70);
    }

    const partial = buildLedgerFromTxs(txs, wallet);
    for (const [mint, v] of partial.entries()){
      const cur = LAST_LEDGER.get(mint) || { buyUsd:0, buyQty:0, sellUsd:0, notes:"" };
      cur.buyUsd += v.buyUsd || 0;
      cur.buyQty += v.buyQty || 0;
      cur.sellUsd += v.sellUsd || 0;
      cur.notes = [cur.notes, v.notes].filter(Boolean).join(",");
      LAST_LEDGER.set(mint, cur);
    }

    return { newTx: txs.length };
  }

  async function refreshHoldingsOnly(apiKey, wallet, limitAssets){
    const das = await fetchFungibleHoldings(apiKey, wallet, limitAssets);
    LAST_TOKENS = normalizeFungiblesFromDas(das);
  }

  // ============ Render ============
  function render(tokens, ledger, minUsd){
    const tbody = el("tbody");
    tbody.innerHTML = "";

    const rows = tokens.map(t => {
      const amountUi = t.decimals ? (t.rawAmount / Math.pow(10, t.decimals)) : t.rawAmount;
      const price = Number(t.dasPrice || 0);
      const holdingsUsd = amountUi * price;

      const l = ledger.get(t.mint) || { buyUsd:0, buyQty:0, sellUsd:0, notes:"" };
      const entry = (l.buyQty > 0) ? (l.buyUsd / l.buyQty) : 0;
      const pnlUsd = (holdingsUsd + l.sellUsd) - l.buyUsd;
      const pnlPct = (l.buyUsd > 0) ? (pnlUsd / l.buyUsd) * 100 : NaN;

      return { ...t, amountUi, price, holdingsUsd, entry, soldUsd:l.sellUsd, pnlUsd, pnlPct, notes:l.notes || "" };
    })
    .filter(r => Number.isFinite(r.holdingsUsd) && r.holdingsUsd > 0 && ((minUsd <= 0) ? true : (r.holdingsUsd >= minUsd)))
    .sort((a,b) => (b.holdingsUsd || 0) - (a.holdingsUsd || 0));

    if (!rows.length){
      el("tableWrap").style.display = "none";
      setStatus("NO SIGNAL: tidak ada token tampil. Coba Min USD=0.", "err");
      return;
    }

    rows.forEach((r, idx) => {
      const cls = Number.isFinite(r.pnlUsd) ? (r.pnlUsd >= 0 ? "pos" : "neg") : "";
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${idx + 1}</td>
        <td>
          <div style="font-family:var(--neo);letter-spacing:.08em;">${r.symbol}</div>
          <div style="color:rgba(255,255,255,.62);font-size:12px;margin-top:4px;white-space:normal;">${r.name}</div>
        </td>
        <td class="mono" title="${r.mint}">${fmtMint(r.mint)}</td>
        <td class="num">${r.amountUi.toLocaleString("en-US", { maximumFractionDigits:10 })}</td>
        <td class="num">${r.entry ? fmtPrice(r.entry) : "—"}</td>
        <td class="num">${r.price ? fmtPrice(r.price) : "—"}</td>
        <td class="num">${fmtUsd(r.holdingsUsd)}</td>
        <td class="num">${fmtUsd(r.soldUsd)}</td>
        <td class="num ${cls}">${fmtUsd(r.pnlUsd)}</td>
        <td class="num ${cls}">${Number.isFinite(r.pnlPct) ? r.pnlPct.toFixed(2) + "%" : "—"}</td>
        <td>${r.notes || ""}</td>
      `;
      tbody.appendChild(tr);
    });

    el("tableWrap").style.display = "";
  }

  // ============ Main flow ============
  function hydrateUiHints(){
    const api = el("apiKey").value.trim();
    const w = el("owner").value.trim();
    el("kApi").textContent = api ? `set (${api.length} chars)` : "—";
    el("kWallet").textContent = w ? shortAddr(w) : "—";
  }

  async function analyze(){
    const btn = el("btnAnalyze");
    btn.disabled = true;
    stopAuto();
    setProgress(0);

    const apiKey = el("apiKey").value.trim();
    const wallet = el("owner").value.trim();
    const limitAssets = Number(el("limitAssets").value || 200);
    const limitTx = Math.min(200, Math.max(10, Number(el("limitTx").value || 80)));
    const maxDetails = Math.min(80, Math.max(5, Number(el("maxDetails").value || 25)));
    const minUsd = Number(el("minUsd").value || 0);
    const refreshSec = Number(el("refreshSec").value || 0);

    hydrateUiHints();

    if (!apiKey){ setStatus("NO KEY: Helius API key kosong.", "err"); btn.disabled = false; return; }
    if (!wallet){ setStatus("NO WALLET: isi wallet address.", "err"); btn.disabled = false; return; }

    // reset state when wallet changes
    if (wallet !== LAST_WALLET){
      PROCESSED_SIGS = new Set();
      LAST_LEDGER = new Map();
      LAST_TOKENS = null;
      LAST_WALLET = wallet;
    }

    try{
      setStatus("PHASE 1/4 • pulling DAS holdings…", "muted");
      setProgress(8);
      const das = await fetchFungibleHoldings(apiKey, wallet, limitAssets);
      const tokens = normalizeFungiblesFromDas(das);
      setProgress(22);

      setStatus("PHASE 2/4 • loading signatures…", "muted");
      const sigs = await getSignaturesForAddress(wallet, limitTx);
      setProgress(35);

      const n = Math.min(maxDetails, sigs.length);
      setStatus(`PHASE 3/4 • fetching tx details: 0/${n}…`, "muted");

      const txs = [];
      for (let i = 0; i < n; i++){
        const sig = sigs[i]?.signature;
        if (!sig) continue;

        PROCESSED_SIGS.add(sig);

        try{
          const tx = await getTransaction(sig);
          if (tx) txs.push(tx);
        }catch(e){}

        setStatus(`PHASE 3/4 • fetching tx details: ${Math.min(i+1, n)}/${n}…`, "muted");
        setProgress(35 + Math.round(((i + 1) / n) * 45));
        await sleep(90);
      }

      setStatus("PHASE 4/4 • synthesizing PnL (USDC-only)…", "muted");
      setProgress(88);

      const ledger = buildLedgerFromTxs(txs, wallet);

      LAST_TOKENS = tokens;
      LAST_LEDGER = ledger;

      el("raw").textContent = JSON.stringify({
        sigCount: sigs.length,
        fetchedTxCount: txs.length,
        autoRefreshSec: refreshSec,
        processedSigCount: PROCESSED_SIGS.size,
        ledgerSample: [...ledger.entries()].slice(0, 8)
      }, null, 2);

      setStatus(`LOCKED: token=${tokens.length} • sig=${sigs.length} • tx=${txs.length} • auto=${AUTO_ON ? "ON" : "OFF"}`, "ok");
      setProgress(100);
      render(LAST_TOKENS, LAST_LEDGER, minUsd);

      // auto refresh runs after analyze
      startAuto(wallet, refreshSec, maxDetails);

    }catch(e){
      setStatus(`FAULT: ${e.message}`, "err");
      setProgress(0);
    }finally{
      btn.disabled = false;
    }
  }

  // ============ Boot ============
  (function boot(){
    // restore from localStorage
    el("apiKey").value = localStorage.getItem("HELIUS_API_KEY") || HELIUS_API_KEY_DEFAULT;
    el("owner").value = localStorage.getItem("LAST_WALLET") || "";
    el("refreshSec").value = localStorage.getItem("REFRESH_SEC") || "15";
    setAutoUi((localStorage.getItem("AUTO_ON") || "0") === "1");
    hydrateUiHints();

    el("apiKey").addEventListener("input", () => {
      localStorage.setItem("HELIUS_API_KEY", el("apiKey").value.trim());
      hydrateUiHints();
    });
    el("owner").addEventListener("input", () => {
      localStorage.setItem("LAST_WALLET", el("owner").value.trim());
      hydrateUiHints();
    });
    el("refreshSec").addEventListener("input", () => {
      localStorage.setItem("REFRESH_SEC", String(Number(el("refreshSec").value || 0)));
    });

    el("btnAnalyze").addEventListener("click", analyze);

    el("btnAuto").addEventListener("click", async () => {
      setAutoUi(!AUTO_ON);
      localStorage.setItem("AUTO_ON", AUTO_ON ? "1" : "0");

      // if turning off, stop immediately
      if (!AUTO_ON){
        stopAuto();
        setStatus("Auto refresh disabled.", "muted");
        return;
      }

      // if already analyzed, start immediately
      const wallet = el("owner").value.trim();
      const refreshSec = Number(el("refreshSec").value || 0);
      const maxDetails = Number(el("maxDetails").value || 25);

      if (wallet && LAST_TOKENS){
        startAuto(wallet, refreshSec, maxDetails);
        setStatus("Auto refresh enabled.", "ok");
      }else{
        setStatus("Auto ON: klik Analyze dulu untuk mulai sinkronisasi.", "muted");
      }
    });

    window.addEventListener("beforeunload", stopAuto);

    // quick indicator
    el("netBadge").textContent = "LINK: VERCEL / API RPC PROXY";
  })();
</script>
</body>
</html>
